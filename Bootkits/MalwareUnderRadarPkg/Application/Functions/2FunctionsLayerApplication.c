#include <Uefi.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Library/UefiRuntimeServicesTableLib.h>
#include <Library/UefiLib.h>
#include <Library/MemoryAllocationLib.h>
#include <Library/BaseMemoryLib.h>



#include <Protocol/Http.h>
#include <Protocol/ServiceBinding.h>



#include <Functions/Utils/1FunctionsUtilsFiles.h>



#define BUFFER_SIZE 8192


BOOLEAN gRequestCallbackComplete = FALSE;
BOOLEAN gResponseCallbackComplete = FALSE;


VOID
EFIAPI
RequestCallback(
    IN      EFI_EVENT       Event,
    IN      VOID            *Context
)
{
    gRequestCallbackComplete = TRUE;
}


VOID
EFIAPI
ResponseCallback(
    IN      EFI_EVENT       Event,
    IN      VOID        *Context
)
{
    gResponseCallbackComplete = TRUE;
}


EFI_STATUS
FunctionsLayerApplication_DownloadFileFromUrl(

    )
{
    EFI_STATUS                      Status;
    EFI_SERVICE_BINDING_PROTOCOL    *ServiceBinding;
    EFI_HANDLE                      Handle = NULL;
    EFI_HTTP_PROTOCOL               *HttpProtocol;
    EFI_HTTP_CONFIG_DATA            ConfigData;
    EFI_HTTPv4_ACCESS_POINT         IPv4Node;
    EFI_HTTP_REQUEST_DATA           RequestData;
    EFI_HTTP_HEADER                 RequestHeader;
    EFI_HTTP_MESSAGE                RequestMessage;
    EFI_HTTP_TOKEN                  RequestToken;
    EFI_HTTP_RESPONSE_DATA          ResponseData;
    EFI_HTTP_MESSAGE                ResponseMessage;
    EFI_HTTP_TOKEN                  ResponseToken;
    UINT8                           *Buffer;
    EFI_TIME                        Baseline;
    EFI_TIME                        Current;
    UINTN                           Timer;
    UINTN                           Index;
    UINTN                           DownloadedFileLength;
    UINTN                           ContentLength;


    Status = gBS->AllocatePool(
        EfiBootServicesData,
        BUFFER_SIZE,
        (VOID **)&Buffer
    );
    

    Status = gBS->LocateProtocol(
        &gEfiHttpServiceBindingProtocolGuid,
        NULL,
        (VOID **)&ServiceBinding
    );
    

    Status = ServiceBinding->CreateChild(
        ServiceBinding,
        &Handle
    );
    

    Status = gBS->HandleProtocol(
        Handle,
        &gEfiHttpProtocolGuid,
        (VOID **)&HttpProtocol
    );
    

    ConfigData.HttpVersion = HttpVersion11;
    ConfigData.TimeOutMillisec = 0;
    ConfigData.LocalAddressIsIPv6 = FALSE;

    ZeroMem(&IPv4Node, sizeof(IPv4Node));
    IPv4Node.UseDefaultAddress = TRUE;
    ConfigData.AccessPoint.IPv4Node = &IPv4Node;


    Status = HttpProtocol->Configure(
        HttpProtocol,
        &ConfigData
    );
    
    
    RequestData.Method = HttpMethodGet;
    RequestData.Url = L"http://192.168.1.35:9876/test.efi";
    RequestHeader.FieldName = "AA";
    RequestHeader.FieldValue = "BBB";
    RequestMessage.Data.Request = &RequestData;
    RequestMessage.HeaderCount = 1;
    RequestMessage.Headers = &RequestHeader;
    RequestMessage.BodyLength = 0;
    RequestMessage.Body = NULL;
    RequestToken.Event = NULL;
    

    Status = gBS->CreateEvent(
        EVT_NOTIFY_SIGNAL,
        TPL_CALLBACK,
        RequestCallback,
        NULL,
        &RequestToken.Event
    );
    
    
    RequestToken.Status = EFI_SUCCESS;
    RequestToken.Message = &RequestMessage;
    gRequestCallbackComplete = FALSE;
    

    Status = HttpProtocol->Request(
        HttpProtocol,
        &RequestToken
    );
    

    Status = gRT->GetTime(
        &Baseline,
        NULL
    );
    
    
    for (Timer = 0; !gRequestCallbackComplete && Timer < 10;)
    {
        HttpProtocol->Poll(
            HttpProtocol
        );
        if (!EFI_ERROR(gRT->GetTime(&Current, NULL)) && Current.Second != Baseline.Second)
        {
            Baseline = Current;
            ++Timer;
        }
    }
    if (!gRequestCallbackComplete)
    {
        Status = HttpProtocol->Cancel(
            HttpProtocol,
            &RequestToken
        );
    }


    ResponseData.StatusCode = HTTP_STATUS_UNSUPPORTED_STATUS;
    ResponseMessage.Data.Response = &ResponseData;
    ResponseMessage.HeaderCount = 0;
    ResponseMessage.Headers = NULL;
    ResponseMessage.BodyLength = BUFFER_SIZE;
    ResponseMessage.Body = Buffer;
    ResponseToken.Event = NULL;
    

    Status = gBS->CreateEvent(
        EVT_NOTIFY_SIGNAL,
        TPL_CALLBACK,
        ResponseCallback,
        NULL,
        &ResponseToken.Event
    );
    
    
    ResponseToken.Status = EFI_SUCCESS;
    ResponseToken.Message = &ResponseMessage;
    gResponseCallbackComplete = FALSE;


    Status = HttpProtocol->Response(
        HttpProtocol,
        &ResponseToken
    );
    

    Status = gRT->GetTime(
        &Baseline,
        NULL
    );
    
    
    for (Timer = 0; !gResponseCallbackComplete && Timer < 10;)
    {
        HttpProtocol->Poll(
            HttpProtocol
        );
        if (!EFI_ERROR(gRT->GetTime(&Current, NULL)) && Current.Second != Baseline.Second)
        {
            Baseline = Current;
            ++Timer;
        }
    }
    if (!gResponseCallbackComplete)
    {
        Status = HttpProtocol->Cancel(
            HttpProtocol,
            &ResponseToken
        );
    }
    for (Index = 0; Index < ResponseMessage.HeaderCount; ++Index)
    {
        if (!AsciiStriCmp(ResponseMessage.Headers[Index].FieldName, "Content-Length"))
        {
            ContentLength = AsciiStrDecimalToUintn(
                ResponseMessage.Headers[Index].FieldValue
            );
        }
    }

    UINT8 *DownloadedFileBuffer;

    Status = gBS->AllocatePool(
        EfiBootServicesData,
        ContentLength,
        (VOID **)&DownloadedFileBuffer
    );
    
    ZeroMem(DownloadedFileBuffer, ContentLength);
    
    
    DownloadedFileLength = ResponseMessage.BodyLength;


    while (DownloadedFileLength < ContentLength) {
        gBS->Stall(1000*1000);
        ResponseMessage.Data.Response = NULL;
        if (ResponseMessage.Headers != NULL)
        {
            FreePool(ResponseMessage.Headers);
        }
        ResponseMessage.HeaderCount = 0;
        ResponseMessage.BodyLength = BUFFER_SIZE;
        ZeroMem(Buffer, BUFFER_SIZE);

        gResponseCallbackComplete = FALSE;
        
        Status = HttpProtocol->Response(
            HttpProtocol,
            &ResponseToken
        );
        if (EFI_ERROR(Status))
        {
            Print(L"Error HttpProtocol->Response: %r\n", Status);
        }
        else
        {
            Print(L"HttpProtocol->Response successfully\n");
        }

        Status = gRT->GetTime(
            &Baseline,
            NULL
        );
        
        for (Timer = 0; !gResponseCallbackComplete && Timer < 10;)
        {
            HttpProtocol->Poll(
                HttpProtocol
            );
            if (!EFI_ERROR(gRT->GetTime(&Current, NULL)) && Current.Second != Baseline.Second)
            {
                Baseline = Current;
                ++Timer;
            }
        }

        if (!gResponseCallbackComplete)
        {
            Status = HttpProtocol->Cancel(
                HttpProtocol,
                &ResponseToken
            );
            Print(L"Error Response Callback Incomplete: Download failed\n");
        }
        CopyMem(DownloadedFileBuffer + DownloadedFileLength, Buffer, ResponseMessage.BodyLength);
        DownloadedFileLength += ResponseMessage.BodyLength;
    }


    Print(L"File: %d bytes\n", DownloadedFileLength);


    Status = FunctionsUtilsFiles_SaveContentToFile(
        L"\\EFI\\Boot\\test.efi",
        DownloadedFileBuffer,
        DownloadedFileLength
    );


    return EFI_SUCCESS;
}
